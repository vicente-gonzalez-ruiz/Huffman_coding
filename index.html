<!DOCTYPE html> 
<html> 
<head> <title>Huﬀman coding</title> 
<meta charset="UTF-8" /> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" /> 
<link rel="stylesheet" type="text/css" href="index.css" /> 
<script type="text/javascript" 
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" 
></script> 
<style type="text/css"> 
.MathJax_MathML {text-indent: 0;} 
</style> 
</head><body 
>
   <div class="maketitle">
                                                                  

                                                                  
                                                                  

                                                                  

<h2 class="titleHead">Huﬀman coding</h2>
 <div class="author" ><span 
class="ecrm-1200">Vicente Gonz</span><span 
class="ecrm-1200">á</span><span 
class="ecrm-1200">lez Ruiz</span></div><br />
<div class="date" ><span 
class="ecrm-1200">May 13, 2019</span></div>
   </div>
   <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-10001"></a><a 
href="https://en.wikipedia.org/wiki/Huffman_coding" >Basics</a></h3>
     <ul class="itemize1">
     <li class="itemize">Developed by D. Huﬀman in 1952 <span class="cite">[<a 
href="#Xhuffman1952method">1</a>]</span>.
     </li>
     <li class="itemize">(Absolute) Optimal performance (in average, better than Shannon-Fano)
     when a integer number of bits is assigned to each symbol.
     </li>
     <li class="itemize">Huﬀman-based VLC codecs build a binary tree where the symbols are
     stored in the leafs and the distance of each symbol to the root of the tree
     is
<div class="math-display"><!--l. 22--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mrow 
>
                            <mrow ><mo 
class="MathClass-open">⌈</mo><mrow><msub><mrow 
><mo class="qopname">log</mo><!--nolimits--></mrow><mrow 
><mn>2</mn></mrow></msub 
><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>p</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>s</mi></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow><mo 
class="MathClass-close">⌉</mo></mrow>
</mrow></math></div>
     <!--l. 22--><p class="nopar" >.
                                                                  

                                                                  
     </p></li>
     <li class="itemize">After label each binary branch in the tree, the Huﬀman code-word for the
     symbol <!--l. 25--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi></mrow></math>
     is the sequence of bits (labels) that we must use to travel from the root to
     the <!--l. 26--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi></mrow></math>-leaf.</li></ul>
<!--l. 29--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-20002"></a>Building Huﬀman trees</h3>
<!--l. 30--><p class="noindent" >
     </p><ol  class="enumerate1" >
     <li 
  class="enumerate" id="x1-2002x1">Create a list of nodes. Each node stores a symbol and its probability.
     </li>
     <li 
  class="enumerate" id="x1-2004x2">While the number of nodes in the list &#x003E; 1:
         <ol  class="enumerate2" >
         <li 
  class="enumerate" id="x1-2006x1">Extract from the list the 2 nodes with the lowest probability.
         </li>
         <li 
  class="enumerate" id="x1-2008x2">Insert in the list a new node (that is the root of a binary tree) whose
         probability is the sum of the probability of its leafs.</li></ol>
     </li></ol>
<!--l. 46--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.1   </span> <a 
 id="x1-30002.1"></a>Example</h4>
<!--l. 47--><p class="noindent" > <div style="text-align:center;"> <img width=600 src="graphics/huffman_ejemplo.png" /> </div> 
</p><!--l. 49--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-40003"></a>Encoder</h3>
<!--l. 50--><p class="noindent" >
     </p><ol  class="enumerate1" >
     <li 
  class="enumerate" id="x1-4002x1">n := |C|;
     </li>
     <li 
  class="enumerate" id="x1-4004x2">Q := C;
     </li>
     <li 
  class="enumerate" id="x1-4006x3"><span 
class="ecbx-1000">for </span>i := 1 <span 
class="ecbx-1000">to </span>n-1 <span 
class="ecbx-1000">do</span>
         <ol  class="enumerate2" >
         <li 
  class="enumerate" id="x1-4008x4">allocate a new node z
                                                                  

                                                                  
         </li>
         <li 
  class="enumerate" id="x1-4010x5">z.left := x := Extract-min(Q);
         </li>
         <li 
  class="enumerate" id="x1-4012x6">z.right := y := Extract-min(Q);
         </li>
         <li 
  class="enumerate" id="x1-4014x7">z.freq := x.freq + y.freq;
         </li>
         <li 
  class="enumerate" id="x1-4016x8">Insert(Q,z);</li></ol>
     </li>
     <li 
  class="enumerate" id="x1-4018x4"><span 
class="ecbx-1000">end for</span>
     </li>
     <li 
  class="enumerate" id="x1-4020x5"><span 
class="ecbx-1000">return </span>Extract-min(Q); {return the root of the tree}</li></ol>
<!--l. 78--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">3.1   </span> <a 
 id="x1-50003.1"></a>Example</h4>
<!--l. 80--><p class="noindent" >String: BACADAEAFABBAAAGAH
</p>
   <div class="tabular"> <table id="TBL-2" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-2-1g"><col 
id="TBL-2-1" /><col 
id="TBL-2-2" /><col 
id="TBL-2-3" /><col 
id="TBL-2-4" /><col 
id="TBL-2-5" /><col 
id="TBL-2-6" /><col 
id="TBL-2-7" /><col 
id="TBL-2-8" /><col 
id="TBL-2-9" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-2-1-"><td  style="text-align:center; white-space:nowrap;" id="TBL-2-1-1"  
class="td11">           A                 </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-1-2"  
class="td11">  B   </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-1-3"  
class="td11">  C   </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-1-4"  
class="td11">  D    </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-1-5"  
class="td11">  E    </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-1-6"  
class="td11">  F    </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-1-7"  
class="td11">  G    </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-1-8"  
class="td11">  H    </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-2-"><td  style="text-align:center; white-space:nowrap;" id="TBL-2-2-1"  
class="td11"> Frequency (in thousands)  </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-2-2"  
class="td11">  50   </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-2-3"  
class="td11">  20   </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-2-4"  
class="td11">   5    </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-2-5"  
class="td11">   5    </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-2-6"  
class="td11">   5    </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-2-7"  
class="td11">   5    </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-2-8"  
class="td11">   5    </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-2-9"  
class="td11">   5    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-3-"><td  style="text-align:center; white-space:nowrap;" id="TBL-2-3-1"  
class="td11">  Fixed-length codeword    </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-3-2"  
class="td11"> 000  </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-3-3"  
class="td11"> 001  </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-3-4"  
class="td11">  010   </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-3-5"  
class="td11">  011   </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-3-6"  
class="td11">  100   </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-3-7"  
class="td11">  101   </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-3-8"  
class="td11">  110   </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-3-9"  
class="td11">  111   </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-4-"><td  style="text-align:center; white-space:nowrap;" id="TBL-2-4-1"  
class="td11"> Variable-length codeword  </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-4-2"  
class="td11">  0   </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-4-3"  
class="td11"> 100  </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-4-4"  
class="td11"> 1010  </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-4-5"  
class="td11"> 1011  </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-4-6"  
class="td11"> 1100  </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-4-7"  
class="td11"> 1101  </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-4-8"  
class="td11"> 1110  </td><td  style="text-align:center; white-space:nowrap;" id="TBL-2-4-9"  
class="td11"> 1111  </td> </tr></table>
</div>
<!--l. 90--><p class="indent" >    <div style="text-align:center;"> <img width=800 src="graphics/huffman_encoder.png" /> </div> 
</p><!--l. 92--><p class="indent" >   OUTPUT: 10001010010110110001101010010000111001111
</p><!--l. 94--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">4   </span> <a 
 id="x1-60004"></a>Decoder</h3>
<!--l. 95--><p class="noindent" >
     </p><ol  class="enumerate1" >
     <li 
  class="enumerate" id="x1-6002x1">prob_table := freq //Array with the frequency of occurrence of each char
     </li>
     <li 
  class="enumerate" id="x1-6004x2">sec := str // Output that we want to rebuild
     </li>
     <li 
  class="enumerate" id="x1-6006x3">tree := array //A key-value associating array, with each item&#x2019;s key the
     node in that subtree and value its current sum probability, according to
     prob_table
     </li>
     <li 
  class="enumerate" id="x1-6008x4">code_table := table //An array with length of the how many characters in
     prob_table, wich maps each code to its corresponding decoded character
     with each code initialised as empty strings.
                                                                  

                                                                  
     </li>
     <li 
  class="enumerate" id="x1-6010x5"><span 
class="ecbx-1000">while </span>more than one node in tree <span 
class="ecbx-1000">do </span>sub_nodes := key of node with
     smallest probability in <span 
class="ecti-1000">tree sec_sub_nodes </span>= key of := key of node with
     second smallest propability in <span 
class="ecti-1000">tree</span>
     <!--l. 115--><p class="noindent" >
         </p><ol  class="enumerate2" >
         <li 
  class="enumerate" id="x1-6012x6"><span 
class="ecbx-1000">for </span>node in sub_nodes <span 
class="ecbx-1000">do</span>
             <ol  class="enumerate3" >
             <li 
  class="enumerate" id="x1-6014x7">code_table[node].key := “1” + code_table[node].key;</li></ol>
         </li>
         <li 
  class="enumerate" id="x1-6016x7"><span 
class="ecbx-1000">end for</span>
         </li>
         <li 
  class="enumerate" id="x1-6018x8"><span 
class="ecbx-1000">for </span>node in sec_sub_nodes <span 
class="ecbx-1000">do</span>
         <!--l. 133--><p class="noindent" >
             </p><ol  class="enumerate3" >
             <li 
  class="enumerate" id="x1-6020x10">code_table[node].key = “0” + code_table[node].key</li></ol>
         </li>
         <li 
  class="enumerate" id="x1-6022x9"><span 
class="ecbx-1000">end for</span>
         </li>
         <li 
  class="enumerate" id="x1-6024x10">tree[sub_nodes + sec_sub_nodes] := tree[sub_nodes] +
         tree[sec_sub_nodes]
         </li>
         <li 
  class="enumerate" id="x1-6026x11">delete tree[sub_nodes]
         </li>
         <li 
  class="enumerate" id="x1-6028x12">delete tree[sec_sub_nodes]</li></ol>
     </li>
     <li 
  class="enumerate" id="x1-6030x6"><span 
class="ecbx-1000">end while</span>
     </li>
     <li 
  class="enumerate" id="x1-6032x7">temp := &#x0022;&#x0022;
     </li>
     <li 
  class="enumerate" id="x1-6034x8">result := &#x0022;&#x0022;
     </li>
     <li 
  class="enumerate" id="x1-6036x9"><span 
class="ecbx-1000">for </span>code in seq <span 
class="ecbx-1000">do</span>
     <!--l. 159--><p class="noindent" >
         </p><ol  class="enumerate2" >
         <li 
  class="enumerate" id="x1-6038x19">temp := temp + code
         </li>
         <li 
  class="enumerate" id="x1-6040x20"><span 
class="ecbx-1000">if </span>temp in code_table <span 
class="ecbx-1000">then</span>
         <!--l. 168--><p class="noindent" >
             </p><ol  class="enumerate3" >
             <li 
  class="enumerate" id="x1-6042x21">result := result + code_table[temp]
             </li>
             <li 
  class="enumerate" id="x1-6044x22">temp := &#x0022;&#x0022;</li></ol>
         </li>
                                                                  

                                                                  
         <li 
  class="enumerate" id="x1-6046x21"><span 
class="ecbx-1000">end if</span></li></ol>
     </li>
     <li 
  class="enumerate" id="x1-6048x10"><span 
class="ecbx-1000">end for</span>
     </li>
     <li 
  class="enumerate" id="x1-6050x11">return result</li></ol>
<!--l. 186--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">4.1   </span> <a 
 id="x1-70004.1"></a>Example</h4>
<!--l. 187--><p class="noindent" > <div style="text-align:center;"> <img width=1200 src="graphics/huffman_decoder.jpeg" /> </div>  INPUT: <span 
class="ecbx-1000">BACADAEAFABBAAAGAH</span>
</p><!--l. 190--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">5   </span> <a 
 id="x1-80005"></a>Limits</h3>
     <ul class="itemize1">
     <li class="itemize">Any Huﬀman code satisﬁes that <table class="equation"><tr><td> <a 
 id="x1-8001r1"></a>
     <!--l. 193--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                          <mi 
>l</mi><mstyle mathsize="1.19em"><mfenced separators="" 
open="("  close="" ><mrow></mrow></mfenced></mstyle><mi 
>c</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>s</mi></mrow><mo 
class="MathClass-close">)</mo></mrow><mstyle mathsize="1.19em"><mfenced separators="" 
open=")"  close="" ><mrow></mrow></mfenced></mstyle> <mo 
class="MathClass-rel">=</mo> <mrow ><mo 
class="MathClass-open">⌈</mo><mrow><mi 
>I</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>s</mi></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow><mo 
class="MathClass-close">⌉</mo></mrow><mo 
class="MathClass-punc">,</mo>
                                                                                        <mstyle 
   id="x1-8002r0"  class="label" ></mstyle><!--endlabel-->
</math></td><td class="eq-no">(Eq:Huﬀman)<a 
 id="x1-8003r0"></a></td></tr></table>
     <!--l. 195--><p class="noindent" >where <!--l. 195--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>l</mi><mstyle mathsize="1.19em"><mfenced separators="" 
open="("  close="" ><mrow></mrow></mfenced></mstyle><mi 
>c</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>s</mi></mrow><mo 
class="MathClass-close">)</mo></mrow><mstyle mathsize="1.19em"><mfenced separators="" 
open=")"  close="" ><mrow></mrow></mfenced></mstyle></mrow></math>
     is the length of the code-word assigned to the symbol
     <!--l. 196--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi></mrow></math>.
     This implies that, with each encoded symbol, up to 1 bit of redundant data
     can be introduced (think about a very frequent – high probability –
     symbol).
     </p></li>
     <li class="itemize">This is a problem that grows when the size of the alphabet is small. In the
     extreme case, for binary source alphabets, the Huﬀman coding does not change
     the length of the original representation.</li></ul>
                                                                  

                                                                  
<!--l. 1--><p class="noindent" >
</p>
   <h3 class="likesectionHead"><a 
 id="x1-90005"></a>References</h3>
<!--l. 1--><p class="noindent" >
   </p><div class="thebibliography">
   <p class="bibitem" ><span class="biblabel">
 [1]<span class="bibsp">   </span></span><a 
 id="Xhuffman1952method"></a>David A       Huﬀman.                     <a 
href="https://scholar.google.es/scholar?hl=es&as_sdt=0%2C5&q=huffman+method+codes+1952&btnG=" >A       method       for       the
   construction of minimum-redundancy codes</a>. <span 
class="ecti-1000">Proceedings of the Institute of</span>
   <span 
class="ecti-1000">Radio Engineers (IRE)</span>, 40(9):1098–1101, 1952.
</p>
   </div>
    
</body> 
</html>
                                                                  


